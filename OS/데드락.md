# DeadLock
- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다.


![image](https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28?original)
- 데드락이 발생할 수 있는 경우 :
P1과 P2가 리소스 A, B 둘 다를 얻어야 한다고 가정할 때, t1에 P1이 리소를 A를 얻고 P2가 리소스 B를 얻었다면 t2때 P1은 리소스 B를, P2는 리소스 A를 기다리게 된다. 하지만 서로 원하는 리소스가 상대방에게 할당되어 있기 때문에 이 두 프로세스는 무한정 기다리게 되는데 이러한 상태를 DeadLock상태라고 한다.

- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황이 발생 할 수 있다.

- 어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 대기 상태로 들어 가게된다.

- 대기 상태로 들어간 프로세스들이 실행 상태로 변경 될 수 없을 때 이러한 상황을 교착 상태라 한다.

 

## 데드락 (Dead lock)의 발생 조건

- 교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립 할 때 발생합니다

- 따라서, 아래의 네 가지 조건 중 하나라도 성립하지 않도록 만든다면 교착 상태를 해결할 수 있습니다.

1. 상호 배제 (Mutual exclusion)
    - 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

 2. 점유 대기 (Hold and wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

 3. 비선점 (No preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

 4. 순환 대기 (Circular wait)
    - 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.

 

## 데드락 (Dead lock) 처리
> 교착 상태 예방(Prevention) 및 회피(Avoidance)

**예방(Prevention)법**
> 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법
    - 자원의 낭비가 심하다.

1. 상호 배제 (Mutual exclusion) 부정
    - 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.

2. 점유 대기 (Hold and wait) 부정
    - 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.

3. 비선점 (No preemption) 부정
    - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

4. 순환 대기 (Circular wait) 부정
    - 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

  

**회피(Avoidance)법**
> 교착 상태가 발생하면 피해나가는 방법

- 은행원 알고리즘 (Banker’s Algorithm) : E,J,Dijkstra가 제안한 방법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법이다. 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법