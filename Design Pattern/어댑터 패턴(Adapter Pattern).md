# 어댑터 패턴(Adapter Pattern)

> 서로 일치하지 않는 인터페이스를 가진 클래스를 함께 동작시킨다.

## 특징

- 현재 사용하고 있는 라이브러리가 더 이상 요구에 부합하지 않아 재작성하거나, 다른 라이브러리를 사용해야 할 때가 있다. 다른 라이브러리를 사용하는 경우 Adapter 패턴을 이용해 기존 코드를 가능한 적게 변경하면서 새로운 라이브러리로 교체할 수 있다.
- 기존 버전의 클래스가 다른 인터페이스를 가지도록, 예를 들어 메소드의 파라미터를 변경하거나 반환 값의 타입을 변경해야 한다면? 기존 버전과 새로운 버전의 메소드를 모두 갖는 비대한 클래스를 만들 수도 있을 것이다. 하지만 대부분의 경우 심플한 클래스(새로운 버전)를 만들고 Adapter를 이용하여 새로운 객체가 기존 코드에 존재하는 것처럼 보이게 하는 것이 더 낫다.
- 어댑터 패턴을 활용해서 리팩토링 하는 경우
  - 두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 서로 다른 경우.
  - 두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우.
  - 외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 인터페이스가 프레임워크의 일부라서 이미 많은 클라이언트에서 사용되고 있는 경우, 또는 소스 코드를 갖고 있지 않는 경우.

## 요약

![image](https://johngrib.github.io/wiki/pattern/adapter/adapter-head-first-281.svg)

### 상황

- Client는 Target 인터페이스를 구현한 Adaptee가 필요하다.
- Adaptee는 Target인터페이스를 구현하지 않고 있다.
  - Adaptee는 이미 개발이 완료되어 사용중이다.
  - Adaptee를 변경하는 것이 적절하지 않은 상황이다.

### 수정

- Adapter 클래스를 만들고, Adaptee를 내부에 갖고 있게 한다.
  - Adapter는 Target을 구현한다.
  - Adapter의 request()는 Adaptee의 specificRequest()를 감싸고 있다.

### 결과

- 이제 Adaptee를 다음과 같이 Adapter에 집어넣어서 Target 인터페이스로 사용할 수 있다.
