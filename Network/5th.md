# UDP, 대칭키 & 공개키, HTTP & HTTPS, TLS/SSL handshake, 로드밸런싱(Load Balancing)

# UDP

> User Datagram Protocol은 비연결형, 신뢰성이 없는 전송 프로토콜이다.
> IP데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.
> UDP는 TCP/IP 5계층에서 Transport Layer(전송계층)의 프로토콜이다.

## 특징

- UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다.
- 내용이 전송 중에 손실 될 수 있고, 전송되는 세그먼트의 순서가 바뀔 수 있다.
- UDP는 TCP보다 간단하고 빠르다.
- 작은 header size를 가지고 있다.
- 흐름제어를 하지 않기 때문에 전송 속도를 최대한 빠르게 할 수 있다.
- 수신자와 송신자 간의 handshaking이 없는 connectionless 성질을 가진다.
- **UDP는 TCP와 다르게 흐름제어나 오류제어 등이 없기 때문에 전송 속도를 최대한 빠르게 할 수 있다. 하지만 TCP처럼 신뢰성 있는 전송을 보장할 수 없다. 따라서 신뢰성보다 속도가 중요한 부문에서 UDP를 사용하게 된다. 예를 들어 유튜브 동영상 같은 스트리밍 어플리케이션은 신뢰성보다 속도가 중요하므로 UDP를 사용한다. 또한 DNS나 SNMP도 UDP를 사용한다.**

## UDP checksum

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3oJdT%2FbtrbljO4lET%2Fmq8qkOivmkGrL2jsLyMLeK%2Fimg.png)

UDP segment header에 보면 checksum 이라는 항목이 있다. 이것은 전송된 segment의 에러를 탐지하기 위한 것이다.

checksum은 어떻게 계산 할 수 있을까? 다음과 같은 과정을 거치면 된다.

- 도착 IP주소, 송신 포트번호, 수신 포트번호, 데이터 길이, payload 등의 데이터들을 16비트 단위로 쪼개서 전부 더한다.
- 만약 더하는 도중 overflow되서 carry-out된 값이 있다면 결과에 다시 더해서 sum 값을 만든다.
- 계산한 sum 값을 1의 보수를 취하면 checksum 값이 된다.

이렇게 계산한 checksum 값을 송신측에서 checksum 영역에 넣어서 송신측에 보내면 송신측도 마찬가지로 sum값을 구하고, checksum 값을 구해서 송신측에서 보낸 checksum 과 동일한지 확인한다. 만약 동일하다면 에러가 없는 것이고 동일하지 않다면 에러가 있다는 것을 확인 할 수 있다.

하지만 이 방법에는 결함이 있다. 전송 도중 checksum값이 바뀔 수도 있고 데이터가 변형되었음에도 불구하고 checksum 값이 동일한 경우도 발생할 수 있다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNpwkc%2FbtrbgjovycK%2FIe9wi2QaFnrQ9xWbtFpVX0%2Fimg.png)

위 그림은 checksum을 계산하는 방법의 예시다. 예를 들기 위해 데이터를 2개만 있다고 가정하고 진행했다. 데이터를 모두 더하고 carry-out이 발생했으므로 그 값을 다시 더해주면 sum 값이 나오고, 이 sum 값을 1의 보수를 취하면 checksum이 된다.

# 대칭키 & 공개키

> 공개키 암호화 방식 : 암복호화에 사용하는 키가 서로 다르며 비대칭키 암호화라고도 함
> 대칭키 암호화 방식 : 암복호화에 사용하는 키가 동일함

## 공개키의 특징

- 단점 : 속도가 느림
- 장점 : 키분배 필요 X, 기밀성/인증/부인방지 기능 제공 방식
  - 암호 모드 : 송신자 공개키로 암호화 -> 송신자 사설키로 복호화
    소량의 메시지 암호화 목적, 주로 키 교환의 용도로 사용
  - 인증 모드 : 송신자 사설키로 암호화 -> 송신자 공개키로 복호화
    메시지를 인증(부인방지)하는 것이 목적
- 대표적인 알고리즘
  - Diffie Hellman : 최초의 공개키 알고리즘, 위조에 취약
  - RSA : 대표적 공개키 알고리즘
  - DSA : 전자서명 알고리즘 표준
  - ECC : 짧은 키로 높은 암호 강도, 빠른 구현 가능 PDA, 스마트폰등에 사용

## 대칭키의 특징

- 장점 : 암호화방식에 속도가 빠르다. 대용량 Data 암호화에 적합하다.
- 단점 : 키를 교환해야 하는 문제, 탈취 관리 걱정, 사람이 증가할수록 키관리가 어려워짐, 확장성 떨어짐
- Session Key, Secret Key, Shared Key, 대칭키, 단용키라고도 함
- 기밀성을 제공하나, 무결성/인증/부인방지 를 보장하지 않음
- 대표적 알고리즘 : 공인인증서의 암호화방식으로 유명한 SEED, DES, 3DES, AES, ARIA, 최근 주목받고 있는 암호인 ChaCha20

## 디지털 인증서 원리

디지털 인증서에는 모두가 신뢰할 수 있는 제삼자인 CA와 비대칭키 암호화가 필요.

1. B는 CA에게 자신이 B임을 증명하고 자신의 공개 키가 B의 공개 키가 맞음을 인증하는 인증서 발급.
2. A에게 B의 공개키가 포함된 이 인증서를 주면,
3. 이를 받은 A는 자신이 신뢰할 수 있는 CA에게 CA가 진짜 발급한 인증서인지 확인하고,
4. 맞으면 그 인증서에 포함된 B의 공개 키로 데이터를 암호화해서 B에게 전달

만약 최종적으로 B가 올바르게 자신의 개인키로 복호화한다면, CA가 인증하는 B의 공개키에 대응하는 개인키를 가지고 있다는 것이므로, 이 과정을 통해 현재 통신하고 있는 상대방이 B가 맞음을 인증할 수 있음.

# HTTP & HTTPS

## HTTP

> 서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜이다. 웹 서핑을 할 때 서버에서 자신의 브라우저로 데이터를 전송해 주는 용도로 가장 많이 사용된다. 인터넷 초기에 모든 웹사이트에서 기본적으로 사용되었던 프로토콜이기도 하다.

- 프로토콜 : 컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계이다. 기기 간 통신은 교환되는 데이터의 형식에 대해 상호 합의를 요구한다. 이런 형식을 정의하는 규칙의 집합

## HTTPS

> HTTP 포로토콜의 문제점은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 점이다. 이 말은 즉, 데이터가 쉽게 도난당할 수 있다는 것이다. HTTPS 프로토콜은 SSL(보안 소켓 계층)을 사용함으로써 이 문제를 해결했다. SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고 서버 브라우저가 민감한 정보를 주고받을 때 이것이 도난당하는 것을 막아준다.

### HTTPS 통신 흐름

1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.

2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.

- CA란? : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업

3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.

4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.

5. 클라이언트가 main.html 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.

- CA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)

6. 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다.

7. 클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-key(대칭키) 를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보냅니다.

8. A서버는 암호화된 대칭키를 자신의 개인키로 복호화 하여 클라이언트와 동일한 대칭키를 획득합니다.

9. 이후 클라이언트-서버사이의 통신을 할 때 주고받는 메세지는 이 pre-master-key(대칭키)를 이용하여 암호화, 복호화를 진행합니다.

ps) 신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등이 있어 무조건 안전한 것은 아니다.

# TLS/SSL HandShake

## SSL Handshake

> Handshake는 악수를 의미하는데, 통신을 하는 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정이 악수와 비슷하여 붙여진 이름이다.

## TSL은 SSL의 업데이트 버전이며 명칭만 다르다고 볼 수 있다.

# 로드 밸런싱(Load Balancing)

> 부하분산 또는 로드 밸런싱(load balancing)은 컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미한다.

## Load Balancing algorithm 종류

- 라운드 로빈 방식
  라운드 로빈(Round Robin Method)은 클라이언트로부터 받은 요청을 로드밸런싱 대상 서버에 순서대로 할당받는 방식입니다. 첫 번째 요청은 첫 번째 서버, 두 번째 요청은 두 번째 서버, 세 번째 요청은 세 번째 서버에 할당합니다. 로드밸러닝 대상 서버의 성능이 동일하고 처리 시간이 짧은 애플리케이션의 경우, 균등하게 분산이 이루어지기 때문에 이 방식을 사용합니다.

- 가중 라운드 로빈 방식
  가중 라운드 로빈 방식(Weighted Round Robin Method)은 실제 서버에 서로 다른 처리 용량을 지정할 수 있습니다. 각 서버에 가중치를 부여할 수 있으며, 여기서 지정한 정숫값을 통해 처리 용량을 정합니다.

- 최소 연결 방식
  최소 연결 방식은 연결 수가 가장 적은 서버에 네트워크 연결방향을 정합니다. 동적인 분산 알고리즘으로 각 서버에 대한 현재 연결 수를 동적으로 카운트할 수 있고, 동적으로 변하는 요청에 대한 부하를 분산시킬 수 있습니다.
